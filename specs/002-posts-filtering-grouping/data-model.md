# Data Model: Posts Filtering and Grouping Enhancements

**Feature**: Posts Filtering and Grouping Enhancements
**Date**: 2026-01-02
**Status**: Design Complete

## Overview

This document defines the data entities, relationships, and validation rules for the filtering and grouping feature. All types use TypeScript with Zod validation following project conventions.

---

## 1. Filter Configuration

### FilterSettings

Represents user-defined filter criteria for posts.

**TypeScript Definition**:

```typescript
// extension/lib/filters/types.ts
import { z } from "zod";

export const FilterSettingsSchema = z.object({
  positiveKeywords: z.array(z.string().min(1).max(100)).default([]),
  negativeKeywords: z.array(z.string().min(1).max(100)).default([]),
  caseSensitive: z.boolean().default(false),
  searchFields: z
    .array(z.enum(["contentHtml", "authorName"]))
    .default(["contentHtml", "authorName"]),
});

export type FilterSettings = z.infer<typeof FilterSettingsSchema>;
```

**Fields**:

- `positiveKeywords`: Array of keywords to include (show only posts containing ANY of these)

  - Validation: 1-100 characters per keyword, max 50 keywords
  - Default: `[]` (empty = show all posts)
  - Example: `["apartment", "flat", "2br"]`

- `negativeKeywords`: Array of keywords to exclude (hide posts containing ANY of these)

  - Validation: 1-100 characters per keyword, max 50 keywords
  - Default: `[]` (empty = no exclusions)
  - Example: `["sold", "rented", "unavailable"]`

- `caseSensitive`: Whether keyword matching is case-sensitive

  - Validation: Boolean
  - Default: `false` (case-insensitive matching per spec Assumption #1)

- `searchFields`: Which post fields to search in
  - Validation: Must be array containing 'contentHtml' and/or 'authorName'
  - Default: `['contentHtml', 'authorName']` (search both)

**Storage**:

```typescript
// Persisted in chrome.storage.local
const FILTER_STORAGE_KEY = "filterSettings";

// Save
// TODO: use import { storage } from "wxt/utils/storage"; instead of chrome storage
await chrome.storage.local.set({ [FILTER_STORAGE_KEY]: filterSettings });

// Load
const { filterSettings } = await chrome.storage.local.get(FILTER_STORAGE_KEY);
```

**Validation Rules**:

- At least one search field must be selected
- Keywords are trimmed of whitespace before storage
- Empty string keywords are automatically removed
- Duplicate keywords are deduplicated
- Filter precedence: Negative filters override positive filters (spec Assumption #2)

---

## 2. Post Grouping

### PostGroup

Represents a collection of posts with identical normalized text content.

**TypeScript Definition**:

```typescript
// extension/lib/grouping/types.ts
import { z } from "zod";

export const PostGroupSchema = z.object({
  id: z.string(), // Hash of normalizedContent for stable ID
  normalizedContent: z.string().min(10).max(10000),
  postIds: z.array(z.string()).min(1),
  firstSeenAt: z.number().int().positive(),
  count: z.number().int().positive(),
  seenCount: z.number().int().nonnegative(),
  isExpanded: z.boolean().default(false),
});

export type PostGroup = z.infer<typeof PostGroupSchema>;
```

**Fields**:

- `id`: Unique identifier for the group

  - Generated as: `hash(normalizedContent)` using simple hash function
  - Stable across grouping operations
  - Example: `"grp_a7f3b2c1"`

- `normalizedContent`: Normalized version of post text used for grouping

  - Validation: 10-10,000 characters (skip very short posts)
  - Generated by: `normalizeContent(post.contentHtml)`
  - Normalization: Strip HTML → collapse whitespace → lowercase → trim

- `postIds`: Array of Post IDs belonging to this group

  - Validation: At least 1 post (groups with single posts may be filtered out in UI)
  - Ordered by: Post scrape time (earliest first)
  - Example: `["123", "456", "789"]`

- `firstSeenAt`: Timestamp when first post in group was scraped

  - Validation: Positive integer (Unix timestamp in milliseconds)
  - Used for: Sorting groups chronologically

- `count`: Total number of posts in the group

  - Validation: Positive integer
  - Derived from: `postIds.length`
  - Used for: Display ("3 duplicate posts")

- `seenCount`: Number of posts in group marked as seen

  - Validation: Non-negative integer, ≤ count
  - Derived from: Counting seen posts in `postIds`
  - Used for: Mixed state indicator (0 = unseen, count = seen, else = partial)

- `isExpanded`: Whether group is expanded in UI
  - Validation: Boolean
  - Default: `false` (collapsed per spec Assumption #8)
  - Not persisted: UI state only, resets on page load

**Computed Properties**:

```typescript
interface PostGroupComputed extends PostGroup {
  isFullySeen: boolean; // seenCount === count
  isPartiallySeen: boolean; // seenCount > 0 && seenCount < count
  representativePost: Post; // First post in group (for preview)
}
```

**Storage**:

- Groups are **not persisted** - they are computed on-demand from posts
- Expansion state is ephemeral (resets on page reload)

**Validation Rules**:

- Groups must have at least 2 posts to be meaningful (UI may filter out singles)
- Post IDs in group must exist in the posts collection
- Normalized content must be at least 10 characters (skip short/empty posts)

---

## 3. Grouping Result

### GroupingResult

Container for the output of a grouping operation.

**TypeScript Definition**:

```typescript
// extension/lib/grouping/types.ts
export const GroupingResultSchema = z.object({
  groups: z.map(z.string(), PostGroupSchema),
  ungroupedPostIds: z.array(z.string()),
  totalGroups: z.number().int().nonnegative(),
  totalPostsGrouped: z.number().int().nonnegative(),
  strategyUsed: z.string(),
});

export type GroupingResult = z.infer<typeof GroupingResultSchema>;
```

**Fields**:

- `groups`: Map of normalized content → PostGroup

  - Key: Normalized content string (for O(1) lookups)
  - Value: PostGroup metadata
  - Example: `Map { "looking for 2br apartment" => PostGroup {...} }`

- `ungroupedPostIds`: Posts that don't belong to any group

  - Reasons: Too short (<10 chars), unique content, errors during normalization
  - Example: `["abc123", "def456"]`

- `totalGroups`: Count of groups created

  - Derived from: `groups.size`
  - Used for: Stats display

- `totalPostsGrouped`: Count of posts assigned to groups

  - Validation: Must equal sum of all `group.count` values
  - Used for: Stats display ("500 posts grouped into 50 groups")

- `strategyUsed`: Name of grouping strategy applied
  - Values: `"exact-match"`, `"fuzzy-match"` (future)
  - Used for: Debugging, analytics

**Helper Methods**:

```typescript
class GroupingResultHelper {
  // Get all groups sorted by size (largest first)
  static getSortedGroups(result: GroupingResult): PostGroup[] {
    return Array.from(result.groups.values()).sort((a, b) => b.count - a.count);
  }

  // Get posts for a specific group
  static getPostsInGroup(
    groupId: string,
    allPosts: Post[],
    result: GroupingResult
  ): Post[] {
    const group = result.groups.get(groupId);
    if (!group) return [];

    const postIdSet = new Set(group.postIds);
    return allPosts.filter((p) => postIdSet.has(p.id));
  }

  // Calculate grouping efficiency
  static getGroupingStats(result: GroupingResult) {
    return {
      totalGroups: result.totalGroups,
      totalPostsGrouped: result.totalPostsGrouped,
      ungroupedCount: result.ungroupedPostIds.length,
      averageGroupSize:
        result.totalGroups > 0
          ? result.totalPostsGrouped / result.totalGroups
          : 0,
    };
  }
}
```

---

## 4. Existing Entities (Referenced)

### Post (from lib/types.ts)

No changes to existing Post entity. Grouping and filtering use existing fields.

**Relevant Fields**:

```typescript
interface Post {
  id: string; // Used as PostGroup.postIds member
  contentHtml: string; // Used for grouping and filtering
  authorName: string; // Used for filtering
  scrapedAt: number; // Used for sorting within groups
  seen: boolean; // Used for group.seenCount calculation
  // ... other fields unchanged
}
```

### Group (from lib/types.ts)

No changes to existing Group entity. Not to be confused with PostGroup (different concepts).

### Subscription (from lib/types.ts)

No changes to existing Subscription entity.

---

## 5. State Transitions

### Filter Settings Lifecycle

```
┌─────────────┐
│   Default   │ (positiveKeywords: [], negativeKeywords: [])
│   Filters   │
└──────┬──────┘
       │
       │ User adds keyword
       ▼
┌─────────────┐
│   Active    │ (keywords present)
│   Filters   │
└──────┬──────┘
       │
       │ User clears filters
       ▼
┌─────────────┐
│   Default   │
│   Filters   │
└─────────────┘
```

**Persistence**: Filters persist across browser sessions via chrome.storage.local

### Post Group Lifecycle

```
┌─────────────┐
│   Posts     │
│   Loaded    │
└──────┬──────┘
       │
       │ groupPosts() called
       ▼
┌─────────────┐
│  Collapsed  │ (isExpanded: false, default state)
│   Groups    │
└──────┬──────┘
       │
       │ User clicks expand
       ▼
┌─────────────┐
│  Expanded   │ (isExpanded: true, shows all posts in group)
│   Groups    │
└──────┬──────┘
       │
       │ User clicks collapse OR page refresh
       ▼
┌─────────────┐
│  Collapsed  │
│   Groups    │
└─────────────┘
```

**Ephemeral**: Group expansion state is not persisted (resets on page load per spec design)

---

## 6. Relationships

```
FilterSettings (1) ──applies to──> Posts (N)
    │
    └──> Filters displayed posts


Posts (N) ──grouped by──> PostGroup (1)
    │
    │ (one post can belong to one group or be ungrouped)
    │
    ▼
PostGroup.postIds[] references Post.id


GroupingResult (1) ──contains──> PostGroup (N)
    │
    └──> Also tracks ungrouped Post IDs
```

**Cardinality**:

- 1 FilterSettings instance (global)
- N Posts (from existing storage)
- N PostGroups (computed from posts)
- 1 GroupingResult per grouping operation

---

## 7. Validation Summary

| Entity             | Primary Validation                      | Error Handling                                         |
| ------------------ | --------------------------------------- | ------------------------------------------------------ |
| **FilterSettings** | Zod schema, keyword length/count limits | Invalid keywords are skipped; empty filters = show all |
| **PostGroup**      | Min 10 char content, min 1 post         | Short content posts go to ungroupedPostIds             |
| **GroupingResult** | Total counts must match group sums      | Grouping errors logged, partial results returned       |

---

## 8. Migration Notes

**No database migrations required** - this feature adds new client-side computed state only.

**Storage Impact**:

- FilterSettings: ~1 KB in chrome.storage.local
- PostGroups: Not stored (computed on-demand)
- Total storage increase: <5 KB

**Backward Compatibility**:

- Existing posts, groups, subscriptions unchanged
- New filter settings have safe defaults (empty = no filtering)
- Feature can be disabled by simply not rendering filter UI

---

## Conclusion

The data model is designed for:

- **Performance**: Map-based groups, computed not stored
- **Flexibility**: Strategy pattern allows algorithm swaps
- **Type Safety**: Full Zod validation + TypeScript
- **Simplicity**: Minimal new entities, builds on existing Post model

Ready to proceed to Phase 1: Contracts (API/Interface definitions).
